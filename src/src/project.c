/* Pasquali tractor Instrument Cluster project
 Author: Andrei Diea (github.com/ADiea)
*/

#include <system.h>
#include <gpio.h>
#include <delay.h>
#include <timer.h>
#include <spi.h>
#include <max7219.h>
#include <usart.h>
#include <adc.h>

//The Blue LED is on bit 8 of port C
#define LED_PIN_BLUE 8
#define LED_PIN_GREEN 9

//define a led on delay time of 1s = 1000ms
#define LED_ON_TIME 100

//define a led on delay time of 0.5s = 500ms
#define LED_OFF_TIME 100

//HOMEWORK: PC8 + PC9 can use the TIM3
#define LED_PIN_BLUE_CH 2
#define LED_PIN_GREEN_CH 3

//These pins are alternate function for SPI1 peripheral on port A
//we will not use these pins directly, the SPI peripheral will use them for communication
#define SPI1_NSS_PIN 4
#define SPI1_SCK_PIN 5
#define SPI1_MISO_PIN 6
#define SPI1_MOSI_PIN 7

//USART1 on PORTA
#define USART2_TX 2
#define USART2_RX 3

//ADC - will convert voltage on PA0
#define ADC_PIN 0

//Buffer for value used by display
char displayBuffer[8];


void initSegmentDisplaySoftwareSPI(void)
{
	//we will attach a LED segment display based on MAX7219 chip
	//(see documentation folder for the datasheet)
	//The MAX7219 can be controlled via the SPI communication protocol
	//It then directly controls the LED display

	//We will use software SPI where we control the GPIO pins in software
	//Will we use the following pins which are the same as SPI1 pins but this is not important
	//(!) With software SPI we can use ANY pins since we control them in software
	/*
		PA4 NSS Slave select, will be output
		PA5 SCK Clock signal will be output (clock is generated by mcu)
		PA6 MISO Master in slave out, will be input, but we will not read anything from the display so we ignore it
		PA7 MOSI Master out slave in output the MCU will send commands
	 * */

	//enable GPIOA peripheral to have access to PA 4,5,6,7
	enableAHBPeripheral(ePerif_GPIOA, eEnabled);

	//configure the GPIO pins for software SPI
	spiSoftSetup(GPIOA, SPI1_NSS_PIN, SPI1_SCK_PIN, SPI1_MOSI_PIN, SPI1_MISO_PIN);

	//init the MAX7219 device by sending specific commands
	initMAX7219Display(0);
}

void initUSART2(void)
{
	//enable GPIOA peripheral to have access to PA2 PA3
	enableAHBPeripheral(ePerif_GPIOA, eEnabled);

	//setup alternate functions for the three pins
	//After this step, value of the three pins are
	//no longer controlled by the OutputDataRegister like a normal GPIO pin, but by usart2
	setPinAlternateFunction(GPIOA, USART2_TX, ePin_AF1);
	setPinAlternateFunction(GPIOA, USART2_RX, ePin_AF1);

	//enable USART2 to use it as hardware PWM generator
	enableAPB1Peripheral(ePerif_USART2, eEnabled);

	//setup usart peripheral
	setupUSART(9600);
}

void initADC()
{
	//enable peripheral A
	enableAHBPeripheral(ePerif_GPIOA, eEnabled);

	//set pin as anaog!
	GPIOA->MODER.reg |= ePin_Analog << MODERPOS(ADC_PIN);

	//enable ADC peripheral
	enableAPB2Peripheral(ePerif_ADC, eEnabled);

	//setup ADC
	setupADC();
}

//we cannot use simple / in our project like c = a/b
//undefined reference to `__aeabi_uidiv' => we have to link with a math library or a libc
//undefined reference to `__aeabi_uidivmod' => we have to link with a math library or a libc
//we must link with external library or make custom div and mod functions...we'll make custom div and mod fucntions:)

//returns result of a/b

int div(int a, int b)
{
	int result = 0;

	while(a>=b)
	{
		++result;
		a -= b;
	}
	return result;
}

//returns result of a%b
int mod(int a, int b)
{
	if(a<b)
		return a;

	while(a>=b)
	{
		a -= b;
	}

	//in a we have the remainder
	return a;
}


//convert a value into sepparate ints corrsponding to digit position
//very simple implementation
void intToString(unsigned int value, char *buffer)
{
	//use debugger to see how function works
	int i;
	for(i=0; i<8; i++)
	{
		buffer[i] = mod(value, 10);
		value = div(value, 10);
	}
}

//update the display with values from buffer
void updateDisplayBuffer(char *buffer)
{
	int i;
	clearDisplay();
	for(i=0;i<8;i++)
	{
		putChar(buffer[i], i);
	}
}

//This is the entry-point of our application.
int projectInit(void)
{

  //enable onboard blue led
  enableAHBPeripheral(ePerif_GPIOC, eEnabled);
  setPinMode(GPIOC, LED_PIN_BLUE, ePin_Output);

  //setup the ADC
  initADC();

  //initSegmentDisplay();
  initSegmentDisplaySoftwareSPI();

  initUSART2();

 // int state = 0, i=0;

  unsigned int ADC_value = 0;


  while(1)// Repeat the following forever
  {
	writePin(GPIOC, LED_PIN, 1); // set Bit 8 (turn on LED)
    busyDelayMs(LED_ON_TIME);
    
    writePin(GPIOC, LED_PIN, 0);  // clear Bit 8 (turn off LED)
	busyDelayMs(LED_OFF_TIME);

	ADC_value = convertADC();

	intToString(ADC_value, (char*) displayBuffer);
	updateDisplayBuffer((char*) displayBuffer);

  }
  
  //will never reach this point
  return 0;
}
